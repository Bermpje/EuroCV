# Extractor Architecture

## Overview

EuroCV uses a flexible, plugin-based extractor architecture that automatically detects and uses the most appropriate extractor for each file type.

## Architecture

### Base Interface

All extractors inherit from `ResumeExtractor` which defines:

```python
class ResumeExtractor(ABC):
    @abstractmethod
    def extract(self, file_path: str) -> Resume:
        """Extract resume data from file."""

    @abstractmethod
    def can_handle(self, file_path: str) -> bool:
        """Check if this extractor can handle the given file."""

    @property
    @abstractmethod
    def name(self) -> str:
        """Return extractor name for logging/debugging."""
```

### Auto-Detection

The `get_extractor()` function automatically selects the appropriate extractor:

```python
from eurocv.core.extract.registry import get_extractor

extractor = get_extractor("resume.pdf")  # Automatically selects best extractor
resume = extractor.extract("resume.pdf")
```

Extractors are tried in priority order:
1. **LinkedInPDFExtractor** (most specific)
2. **DOCXExtractor**
3. **GenericPDFExtractor** (fallback for all PDFs)

## Available Extractors

### 1. LinkedInPDFExtractor

**Purpose**: Optimized for LinkedIn-exported PDFs

**Detection**: Checks PDF metadata and content for LinkedIn markers:
- Metadata: `producer` or `creator` contains "linkedin"
- Content: First page contains "linkedin.com" or "generated by linkedin"

**Best for**:
- PDFs exported directly from LinkedIn
- LinkedIn's specific formatting patterns

### 2. GenericPDFExtractor

**Purpose**: Handles various PDF resume formats with multi-language support

**Features**:
- **Multi-language support**: English + Dutch
- **Dutch section headers**: ERVARING, OPLEIDING, VAARDIGHEDEN, TALEN, CERTIFICATEN
- **Dutch date formats**: januari, februari, maart, etc.
- **Present keywords**: heden, nu (in addition to English)
- **Language proficiency**: moedertaal → Native
- **Better name extraction**: Handles whitespace-heavy layouts and sidebar designs

**Best for**:
- Custom-designed CVs
- Dutch-language resumes
- Non-LinkedIn PDF formats
- Sidebar layouts

### 3. DOCXExtractor

**Purpose**: Extracts from Word documents (.docx, .doc)

**Detection**: File extension

**Best for**:
- Microsoft Word resumes
- DOCX templates

## Usage Examples

### Basic Usage

```python
from eurocv import convert_to_europass

# Auto-detection happens automatically
result = convert_to_europass("resume.pdf", output_format="json")
```

### Manual Extractor Selection

```python
from eurocv.core.extract import LinkedInPDFExtractor, GenericPDFExtractor

# Force a specific extractor
extractor = GenericPDFExtractor()
resume = extractor.extract("resume.pdf")
```

### Check Which Extractor Was Used

```python
from eurocv.core.extract.registry import get_extractor

extractor = get_extractor("resume.pdf")
print(f"Using: {extractor.name}")  # e.g., "Generic PDF"
```

### Enable Logging

```python
import logging

logging.basicConfig(level=logging.INFO)

# Now you'll see which extractor is selected:
# INFO:eurocv.core.extract.registry:Selected extractor: Generic PDF for resume.pdf
```

## Supported Languages

### GenericPDFExtractor

Fully supports:
- **English**: Standard resume sections
- **Dutch**: Native language support with Dutch keywords

Section headers recognized:
| Category | English | Dutch |
|----------|---------|-------|
| Work Experience | work experience, experience, employment | ervaring, werkervaring |
| Education | education, academic | opleiding, onderwijs |
| Skills | skills, competencies | vaardigheden, competenties |
| Languages | languages | talen |
| Certifications | certifications, certificates | certificaten |

## Adding New Extractors

To add a new extractor:

1. **Create extractor class**:
   ```python
   from eurocv.core.extract.base_extractor import ResumeExtractor

   class MyExtractor(ResumeExtractor):
       @property
       def name(self) -> str:
           return "My Extractor"

       def can_handle(self, file_path: str) -> bool:
           # Detection logic
           return file_path.endswith('.xyz')

       def extract(self, file_path: str) -> Resume:
           # Extraction logic
           pass
   ```

2. **Register in registry.py**:
   ```python
   EXTRACTORS = [
       SpecificExtractor,  # Most specific first
       MyExtractor,        # Your new extractor
       GenericExtractor,   # Generic last (fallback)
   ]
   ```

3. **Add tests**:
   ```python
   def test_my_extractor():
       extractor = get_extractor("file.xyz")
       assert isinstance(extractor, MyExtractor)
   ```

## Detection Priority

Extractors are checked in order. The first one that returns `True` from `can_handle()` is used.

**Example flow**:
1. Try `LinkedInPDFExtractor.can_handle("resume.pdf")` → False (no LinkedIn markers)
2. Try `DOCXExtractor.can_handle("resume.pdf")` → False (not .docx)
3. Try `GenericPDFExtractor.can_handle("resume.pdf")` → True (accepts all PDFs)
4. Use `GenericPDFExtractor`

## Performance

- **Detection overhead**: Minimal (~10-50ms for PDF metadata check)
- **Caching**: Not currently implemented (detects on every call)
- **File I/O**: Only the selected extractor opens the file

## Limitations

### Current GenericPDFExtractor
- Name extraction may fail with unusual layouts
- Work experience parsing relies on date patterns
- Sidebar content may be mixed with main content
- Certification extraction is basic

### Improvement areas
- Better layout analysis (column detection)
- ML-based entity recognition
- More language support (German, French, Spanish)
- Table extraction

## Troubleshooting

### Wrong extractor selected

```python
import logging
logging.basicConfig(level=logging.INFO)

from eurocv.core.extract.registry import get_extractor
extractor = get_extractor("resume.pdf")
# Check logs to see why
```

### Extractor fails to extract data

Try a different extractor manually:
```python
from eurocv.core.extract import GenericPDFExtractor

extractor = GenericPDFExtractor()
resume = extractor.extract("resume.pdf")
print(f"Found {len(resume.work_experience)} work experiences")
```

### Add debug output

```python
resume = extractor.extract("resume.pdf")
print(resume.raw_text[:500])  # Check raw extracted text
```
